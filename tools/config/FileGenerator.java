

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Date;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.LinkedList;

public class FileGenerator {

    private final static String HEADER_FILENAME = "remote_config.h";
    private final static String SOURCE_FILENAME = "remote_config.c"; 
    
    final static String SPACES = "    ";
    final static String UNDERSCORE = "_";
    final static String ADD = " + ";
    
    final static String INCLUDE_HEADER_STRING = "#include \"" + HEADER_FILENAME + "\"\n\n";
    
    final static String TYPEDEF_ENUM_STRING = "typedef enum {\n";
    
    final static String IDIGI_STRING = "idigi";
    
    final static String DEFINE_STRING = "#define ";
    final static String LENGTH_STRING = "LENGTH";
    final static String INDEX_STRING = "STRING_INDEX";
    final static String ERROR_STRING = "error";
    
    private final static String GLOBAL_ERROR_STRING = "idigi_global_error";
    private final static String GROUP_ERROR_STRING = "idigi_group_error";

    final static String IDIGI_REMOTE_ALL_STRING = "idigi_remote_all_strings";
    
    final static String IDIGI_ERROUR_ENUM_COUNT = "idigi_group_error_COUNT,\n";
    final static String COUNT_STRING = "COUNT";
    
    public FileGenerator() throws IOException 
    {
        
        headerWriter = new BufferedWriter(new FileWriter(HEADER_FILENAME));
        sourceWriter = new BufferedWriter(new FileWriter(SOURCE_FILENAME));
        ConfigGenerator generator = new ConfigGenerator();
        
        DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
        Date date = new Date();
        
        String note_string = "/*\n * This is an auto-generated file - DO NOT EDIT! \n";
        note_string += " * This is generated by " + generator.getClass().getName() + " tool \n";
        note_string += " * This file was generated on: " + dateFormat.format(date) + " \n";
        note_string += " * The command line arguments were: " + ConfigGenerator.getArguments() + " \n";
        note_string += " * The version of " + generator.getClass().getName() + " tool was: " + ConfigGenerator.VERSION + "\n*/\n\n";
        
        headerWriter.write(note_string);
        sourceWriter.write(note_string);
        
        previousName = null;
        
    }
    
    final static String[] ConfigTypes= { Descriptors.STATE_STRING, Descriptors.SETTING_STRING};
    
    public void generateFile(ConfigData configData) throws IOException
    {
        try {

            headerWriter.write("#ifndef REMOTE_CONFIG_H\n" + 
                                "#define REMOTE_CONFIG_H\n\n" + 
                                INCLUDE_HEADER_STRING); // H file header
            
            sourceWriter.write(INCLUDE_HEADER_STRING); //  C file include
            
            // Write all global error enum in H file
            writeGlobalErrorHeader(configData.getErrorGroups());
             
//            for (ConfigData theConfig: configList)
            for (String type: ConfigTypes)
            {
                LinkedList<GroupStruct> theConfig = configData.getConfigGroup(type);
                
                if (!theConfig.isEmpty())
                {
                    configType = type;
                
                    // Write all enum in H file
                    writeConfigHeader(theConfig, configData.getErrorGroups());
                
                    // Write all string length and index defines in C file
                    writeDefineStrings(theConfig);
                }
            }
            headerWriter.write("\n#endif /* REMOTE_CONFIG_H */\n"); // end of H file

            // Start writing C file
            
            // Write all string length and index defines in C file
            writeDefineGlobalErrors(configData.getErrorGroups());
            
            // write idigi remote all strings in source file
            sourceWriter.write("\nchar const " + IDIGI_REMOTE_ALL_STRING + "[] = {\n");
            
            for (String type: ConfigTypes)
            {
                LinkedList<GroupStruct> theConfig = configData.getConfigGroup(type);
                
                if (!theConfig.isEmpty())
                {
                    configType = type;
               
                    writeRemoteAllStrings(theConfig);
                }
            }
            writeErrorsRemoteAllStrings(configData.getErrorGroups());
            sourceWriter.write(SPACES + "\'\\0\'\n};\n"); // end of IDIGI_REMOTE_ALL_STRING

            // write structures in source file
            for (String type: ConfigTypes)
            {
                LinkedList<GroupStruct> theConfig = configData.getConfigGroup(type);
                
                if (!theConfig.isEmpty())
                {
                    configType = type;
                    writeStructures(theConfig, configData.getErrorGroups());
                }
            }
            
            for (String type: ConfigTypes)
            {
                String count_string = "size_t const idigi_" + type + "_group_count = ";
                
                if (configData.getConfigGroup(type).isEmpty())
                {
                    count_string += "0\n";
                    count_string += "idigi_group_t const * idigi_" + type + "_groups = NULL;\n";
                }
                else
                {
                    count_string += "asizeof(idigi_" + type + "_groups);\n";
                }
                sourceWriter.write(count_string);
            }
            
        } catch (IOException e) {
            throw new IOException(e.getMessage());
        }
    }
    private void writeDefineStrings(LinkedList<GroupStruct> groups) throws IOException
    {
        String defineName = null;
        
        for (GroupStruct group: groups)
        {
            /* define name length */
            defineName = getDefineString(group.name);
            sourceWriter.write(getDefineLength(defineName, group.name));

            /* define name string inex */
            sourceWriter.write(getDefineIndex(defineName, previousName));
            
            previousName = defineName;
            
            for (ElementStruct element: group.elements)
            {
                /* define name length */
                defineName = getDefineString(group.name, element.name);
                sourceWriter.write(getDefineLength(defineName, element.name));
                
                /* define name string inex */
                sourceWriter.write(getDefineIndex(defineName, previousName));

                previousName = defineName;

                if (ElementStruct.ElementType.toElementType(element.type) == ElementStruct.ElementType.ENUM)
                {
                    for (NameStruct value: element.values)
                    {
                        /* define name length */
                        defineName = getDefineString(group.name, element.name, value.name);
                        sourceWriter.write(getDefineLength(defineName, value.name));
                        
                        /* define name string inex */
                        sourceWriter.write(getDefineIndex(defineName, previousName));
                        previousName = defineName;
                    }
                 }
            }
        
            if (!group.errors.isEmpty())
            {
                
                for (NameStruct error: group.errors)
                {
                    /* define name length */
                    defineName = getDefineString(group.name, ERROR_STRING, error.name);
                    sourceWriter.write(getDefineLength(defineName, error.name));
                    
                    /* define name string inex */
                    sourceWriter.write(getDefineIndex(defineName, previousName));
                    previousName = defineName;
                }
            }
        }
/*        
        for (NameStruct error: errors)
        {
            defineName = getDefineString(ERROR_STRING, error.name);
            sourceWriter.write(getDefineLength(defineName, error.name));
            
            sourceWriter.write(getDefineIndex(defineName, previousName));
            previousName = defineName;
        }
*/        
    }

    private void writeRemoteAllStrings(LinkedList<GroupStruct> groups) throws IOException
    {
        String define_name;
        
        
        for (GroupStruct group: groups)
        {
            define_name = getDefineString(group.name);
            
            sourceWriter.write(getCharString(define_name, group.name));

            for (ElementStruct element: group.elements)
            {
                define_name = getDefineString(group.name, element.name);
                sourceWriter.write(getCharString(define_name, element.name));
                
                if (ElementStruct.ElementType.toElementType(element.type) == ElementStruct.ElementType.ENUM)
                {
                    for (NameStruct value: element.values)
                    {
                        define_name = getDefineString(group.name, element.name, value.name);
                        sourceWriter.write(getCharString(define_name, value.name));
                    }
                 }
            }
        
            if (!group.errors.isEmpty())
            {
                for (NameStruct error: group.errors)
                {
                    define_name = getDefineString(group.name, ERROR_STRING, error.name);
                    sourceWriter.write(getCharString(define_name, error.name));
                }
            }
        }
/*        
        for (NameStruct error: errors)
        {
            define_name = getDefineString(ERROR_STRING, error.name);
            sourceWriter.write(getCharString(define_name, error.name));
        }
*/
    }

    private void writeDefineGlobalErrors(LinkedList<NameStruct> globalerrors) throws IOException
    {
        for (NameStruct error: ConfigGenerator.allErrorList)
        {
            /* define name length */
            String defineName = GLOBAL_ERROR_STRING.toUpperCase() + UNDERSCORE + error.name.toUpperCase();
            sourceWriter.write(getDefineLength(defineName, error.name));
            
            /* define name string inex */
            sourceWriter.write(getDefineIndex(defineName, previousName));
            previousName = defineName;
        }
        for (NameStruct error: ConfigGenerator.globalErrorList)
        {
            /* define name length */
            String defineName = GLOBAL_ERROR_STRING.toUpperCase() + UNDERSCORE + error.name.toUpperCase();
            sourceWriter.write(getDefineLength(defineName, error.name));
            
            /* define name string inex */
            sourceWriter.write(getDefineIndex(defineName, previousName));
            previousName = defineName;
        }
        for (NameStruct error: ConfigGenerator.commandErrorList)
        {
            /* define name length */
            String defineName = GLOBAL_ERROR_STRING.toUpperCase() + UNDERSCORE + error.name.toUpperCase();
            sourceWriter.write(getDefineLength(defineName, error.name));
            
            /* define name string inex */
            sourceWriter.write(getDefineIndex(defineName, previousName));
            previousName = defineName;
        }
        for (NameStruct error: ConfigGenerator.groupErrorList)
        {
            /* define name length */
            String defineName = GLOBAL_ERROR_STRING.toUpperCase() + UNDERSCORE + error.name.toUpperCase();
            sourceWriter.write(getDefineLength(defineName, error.name));
            
            /* define name string inex */
            sourceWriter.write(getDefineIndex(defineName, previousName));
            previousName = defineName;
        }
        for (NameStruct error: globalerrors)
        {
            /* define name length */
            String defineName = GROUP_ERROR_STRING.toUpperCase() + UNDERSCORE + error.name.toUpperCase();
            sourceWriter.write(getDefineLength(defineName, error.name));
            
            /* define name string inex */
            sourceWriter.write(getDefineIndex(defineName, previousName));
            previousName = defineName;
        }
    }

    private void writeErrorsRemoteAllStrings(LinkedList<NameStruct> globalerrors) throws IOException
    {
        for (NameStruct error: ConfigGenerator.allErrorList)
        {
            String define_name = GLOBAL_ERROR_STRING.toUpperCase() + UNDERSCORE + error.name.toUpperCase();
            sourceWriter.write(getCharString(define_name, error.name));
        }
        for (NameStruct error: ConfigGenerator.globalErrorList)
        {
            String define_name = GLOBAL_ERROR_STRING.toUpperCase() + UNDERSCORE + error.name.toUpperCase();
            sourceWriter.write(getCharString(define_name, error.name));
        }
        for (NameStruct error: ConfigGenerator.commandErrorList)
        {
            String define_name = GLOBAL_ERROR_STRING.toUpperCase() + UNDERSCORE + error.name.toUpperCase();
            sourceWriter.write(getCharString(define_name, error.name));
        }
        for (NameStruct error: ConfigGenerator.groupErrorList)
        {
            String define_name = GLOBAL_ERROR_STRING.toUpperCase() + UNDERSCORE + error.name.toUpperCase();
            sourceWriter.write(getCharString(define_name, error.name));
        }
        for (NameStruct error: globalerrors)
        {
            String define_name = GROUP_ERROR_STRING.toUpperCase() + UNDERSCORE + error.name.toUpperCase();
            sourceWriter.write(getCharString(define_name, error.name));
        }
    }

    final static String CHAR_CONST_STRING = "static char const * const ";
    final static String ENUM_STRING = "enum";

    private void writeEnumStructure(String enum_name, LinkedList<NameStruct> values) throws IOException
    {
        String enum_string = enum_name.toLowerCase() + UNDERSCORE + ENUM_STRING;
        
        /* write element enum strings array */
        sourceWriter.write((CHAR_CONST_STRING + enum_string + "[] = {\n"));
        
        for (int value_index = 0; value_index < values.size(); value_index++)
        {
            NameStruct value = values.get(value_index);
            
            /* write idigi_remote_all_strings reference */
            sourceWriter.write(getRemoteAllString(enum_name, value.name));
            if (value_index < (values.size() -1))
            {
                sourceWriter.write(",");
            }
            /* write comment */
            sourceWriter.write(COMMENTED(value.name));
        }
        /* end of writing element enum strings array */
        sourceWriter.write("};\n\n");

        /* write element value limit structure for enum type */
        String enum_limit_string = "static idigi_element_value_enum_t const " + enum_name.toLowerCase() + "_limit = {\n";
        enum_limit_string +=  SPACES + "asizeof(" + enum_string + "), \n" +
                              SPACES + enum_string + "\n};\n\n";

        sourceWriter.write(enum_limit_string);
    }
    
    private void writeElementLimitStructures(String element_name, ElementStruct element) throws IOException
    {
        /* write element value limit structure */
        String limit_string = "static idigi_element_value_unsigned_integer_t const " + element_name.toLowerCase() + "_limit = {\n";
        if (element.min == null)
        {
            limit_string += SPACES + "0";
        }
        else
        {
            limit_string += SPACES + element.min;
        }
        limit_string += ",\n";
        
        if (element.max == null)
        {
            if (ElementStruct.ElementType.toElementType(element.type) == ElementStruct.ElementType.FLOAT)
            {
                limit_string += SPACES + "FLOAT_MAX";
            }
            else
            {
                limit_string += SPACES + "INT_MAX";
            }
        }
        else
        {
            limit_string += SPACES + element.max;
        }
        
        sourceWriter.write(limit_string);
        sourceWriter.write("\n};\n\n");
    }
    
    private void writeElementArrays(String group_name, LinkedList<ElementStruct> elements) throws IOException
    {
        /* write group element structure array */
        sourceWriter.write("static idigi_group_element_t const " + 
                           getDefineString(group_name).toLowerCase() + UNDERSCORE + "elements" +
                           "[] = {");
        
        for (int element_index = 0; element_index < elements.size(); element_index++)
        {
            ElementStruct element = elements.get(element_index);
            
            String element_name = getDefineString(group_name, element.name);
            
            String element_string = "\n" + 
                                    SPACES + "{" + getRemoteAllString(element_name) + ", " + COMMENTED(element.name) + "\n" +
                                    SPACES + getElementDefine("access", element.access) + 
                                    SPACES + getElementDefine("type", element.type);
            
            if (ElementStruct.ElementType.toElementType(element.type) == ElementStruct.ElementType.ENUM ||
                element.min != null || element.max != null)
            {
                element_string += SPACES + SPACES + "(idigi_element_value_limit_t *)&" + 
                                  element_name.toLowerCase() + "_limit";
            }
            else
            {
                element_string += SPACES + SPACES + "NULL";
            }
            element_string += "\n" + SPACES + "}";
            
            if (element_index < (elements.size()-1))
            {
                element_string += ",";
            }
            
            sourceWriter.write(element_string);
        }
        sourceWriter.write("\n};\n\n");

    }

    private void writeErrorStructures(String error_name, LinkedList<NameStruct> localErrors, LinkedList<NameStruct> globalErrors) throws IOException
    {
        String define_name;
        
        if (!ConfigGenerator.allErrorList.isEmpty() || !ConfigGenerator.groupErrorList.isEmpty() || !localErrors.isEmpty() || !globalErrors.isEmpty())
        {
            define_name = getDefineString(error_name, ERROR_STRING);
            sourceWriter.write((CHAR_CONST_STRING + define_name.toLowerCase() + "s[] = {\n"));

            /* top-level global errors */
            for (int error_index = 0; error_index < ConfigGenerator.allErrorList.size(); error_index++)
            {
                NameStruct error = ConfigGenerator.allErrorList.get(error_index);
                sourceWriter.write(getRemoteAllString(GLOBAL_ERROR_STRING.toUpperCase(), error.name));
                if (error_index < (localErrors.size() -1) || !ConfigGenerator.groupErrorList.isEmpty() ||
                   !localErrors.isEmpty() || !globalErrors.isEmpty())
                {
                    sourceWriter.write(",");
                }
                sourceWriter.write(COMMENTED(error.name));
            }

            for (int error_index = 0; error_index < ConfigGenerator.groupErrorList.size(); error_index++)
            {
                NameStruct error = ConfigGenerator.groupErrorList.get(error_index);
                sourceWriter.write(getRemoteAllString(GLOBAL_ERROR_STRING.toUpperCase(), error.name));
                if (error_index < (localErrors.size() -1) || !localErrors.isEmpty() || !globalErrors.isEmpty())
                {
                    sourceWriter.write(",");
                }
                sourceWriter.write(COMMENTED(error.name));
            }

            /* group global errors */
            for (int error_index = 0; error_index < globalErrors.size(); error_index++)
            {
                NameStruct error = globalErrors.get(error_index);
                
                sourceWriter.write(getRemoteAllString(GROUP_ERROR_STRING.toUpperCase(), error.name));
                if (error_index < (localErrors.size() -1) && !localErrors.isEmpty())
                {
                    sourceWriter.write(",");
                }
                sourceWriter.write(COMMENTED(error.name));
            }
            
            /* local local errors */
            define_name = getDefineString(error_name, ERROR_STRING);
            for (int error_index = 0; error_index < localErrors.size(); error_index++)
            {
                NameStruct error = localErrors.get(error_index);
                
                sourceWriter.write(getRemoteAllString(define_name, error.name));
                if (error_index < (localErrors.size() -1))
                {
                    sourceWriter.write(",");
                }
                sourceWriter.write(COMMENTED(error.name));
            }
            
            sourceWriter.write("};\n\n");
        }
    }
    private void writeStructures(LinkedList<GroupStruct> groups, LinkedList<NameStruct> globalerrors) throws IOException
    {
        String define_name;
        
        for (int group_index = 0; group_index < groups.size(); group_index++)
        {
            GroupStruct group = groups.get(group_index);
            
            for (int element_index = 0; element_index < group.elements.size(); element_index++)
            {
                ElementStruct element = group.elements.get(element_index);
                
                define_name = getDefineString(group.name, element.name);

                if (ElementStruct.ElementType.toElementType(element.type) == ElementStruct.ElementType.ENUM)
                {
                    writeEnumStructure(define_name, element.values);
                }
                else if (element.max != null || element.min != null)
                {
                    writeElementLimitStructures(define_name, element);
                }
            }
            
            writeElementArrays(group.name, group.elements);
            
            /* write group error strings array */
            writeErrorStructures(group.name, group.errors, globalerrors);
        }
        
        sourceWriter.write("idigi_group_t const idigi_" + configType + "_groups[] = {");
        
        for (int group_index = 0; group_index < groups.size(); group_index++)
        {
            GroupStruct group = groups.get(group_index);

            
            define_name = getDefineString(group.name, "elements");
            String group_string = "\n" + 
                                    SPACES + "{" + getRemoteAllString(getDefineString(group.name)) + ", " + COMMENTED(group.name) + "\n" +
                                    SPACES + SPACES + "1,\n" + 
                                    SPACES + SPACES + (group.instances + 1) + ",\n" +  
                                    SPACES + SPACES + "{" + SPACES + "asizeof(" + define_name.toLowerCase()  + "),\n" +
                                    SPACES + SPACES + SPACES + "&" + define_name.toLowerCase() + "[0]\n" +
                                    SPACES + SPACES + "},\n";
            
            define_name = getDefineString(group.name, ERROR_STRING);

            group_string +=   SPACES + SPACES + "{" + SPACES + "asizeof(" + define_name.toLowerCase() + "),\n" +
                              SPACES + SPACES + SPACES + "&" + define_name.toLowerCase() + "[0]\n" +
                              SPACES + SPACES + "}\n" +
                              SPACES + "}";
            if (group_index < (groups.size() -1))
            {
                group_string += ",";
            }
                                    
            sourceWriter.write(group_string);
        }
        sourceWriter.write("\n};\n\n");
        
    }

    private void writeGlobalErrorHeader(LinkedList<NameStruct> globalerrors) throws IOException
    {
        if (!ConfigGenerator.allErrorList.isEmpty() || !ConfigGenerator.groupErrorList.isEmpty())
        {
            /* write typedef enum for error */
            headerWriter.write(TYPEDEF_ENUM_STRING);
            
            for (int i = 0; i < ConfigGenerator.allErrorList.size(); i++)
            {
                NameStruct error = ConfigGenerator.allErrorList.get(i);
                String error_string = SPACES + GLOBAL_ERROR_STRING + UNDERSCORE + error.name;
                
                if (i == 0)
                {
                    error_string += " = 1";
                }
                error_string += ",\n";
                
                headerWriter.write(error_string);
            }
            
            for (int i = 0; i < ConfigGenerator.groupErrorList.size(); i++)
            {
                NameStruct error = ConfigGenerator.groupErrorList.get(i);
                String error_string = SPACES + GLOBAL_ERROR_STRING + UNDERSCORE + error.name;
                
                if (i == 0 && ConfigGenerator.allErrorList.size() == 0)
                {
                    error_string += " = 1";
                }
                error_string += ",\n";
                
                headerWriter.write(error_string);
            }

            headerWriter.write(SPACES + GLOBAL_ERROR_STRING + UNDERSCORE + COUNT_STRING + ",\n");
            headerWriter.write(SPACES + GLOBAL_ERROR_STRING + INT_MAX_WIDTH_STRING + GLOBAL_ERROR_STRING + ID_T_STRING);
        }
        
        if (!globalerrors.isEmpty())
        {
            /* write typedef enum for error */
            headerWriter.write(TYPEDEF_ENUM_STRING);
            
            for (int i = 0; i < globalerrors.size(); i++)
            {
                NameStruct error = globalerrors.get(i);
                String error_string = SPACES + GROUP_ERROR_STRING + UNDERSCORE + error.name;
                
                if (i == 0 && ConfigGenerator.allErrorList.size() == 0 && ConfigGenerator.groupErrorList.size() == 0)
                {
                    error_string += " = 1";
                }
                else if (i==0)
                {
                    error_string += "=" + GLOBAL_ERROR_STRING + UNDERSCORE + COUNT_STRING;
                }
                    
                error_string += ",\n";
                
                headerWriter.write(error_string);
            }

            headerWriter.write(SPACES + GROUP_ERROR_STRING + UNDERSCORE + COUNT_STRING + ",\n");
            headerWriter.write(SPACES + GROUP_ERROR_STRING + INT_MAX_WIDTH_STRING + GROUP_ERROR_STRING + ID_T_STRING);
            
        }
    }
    private void writeConfigHeader(LinkedList<GroupStruct> groups, LinkedList<NameStruct> globalerrors) throws IOException
    {
/*
        if (!errors.isEmpty())
        {
            headerWriter.write(TYPEDEF_ENUM_STRING);
            
            for (int i=0; i < errors.size(); i++)
            {
                NameStruct error = errors.get(i);
                String error_string = getEnumString(ERROR_STRING, error.name);
                
                if (i == 0)
                {
                    error_string += " = " + GLOBAL_ERROR_STRING + UNDERSCORE + COUNT_STRING;
                }
                error_string += ",\n";
                
                headerWriter.write(error_string);
            }

            headerWriter.write(getEnumString(ERROR_STRING, COUNT_STRING) + ",\n");
            headerWriter.write(endEnumString(ERROR_STRING));
        }
*/ 
        // build group enum string for group enum
        String group_enum_string = TYPEDEF_ENUM_STRING;

        for (GroupStruct group: groups)
        {
            // build element enum string for element enum
            String element_enum_string = TYPEDEF_ENUM_STRING;
            
            // add each group enum 
            group_enum_string += getEnumString(group.name) + ",\n";
            
            for (ElementStruct element: group.elements)
            {
                // add element name
                element_enum_string += getEnumString(group.name, element.name) + ",\n";
                
                if (ElementStruct.ElementType.toElementType(element.type) == ElementStruct.ElementType.ENUM)
                {
                    // write typedef enum for value
                    headerWriter.write(TYPEDEF_ENUM_STRING);
                    
                    for (NameStruct value: element.values)
                    {
                        headerWriter.write(getEnumString(group.name, element.name, value.name) + ",\n");
                    }
                    // done typedef enum for value 
                    headerWriter.write(endEnumString(group.name, element.name)); 
                }
            }
            // done typedef enum for element
            
            element_enum_string += endEnumString(group.name);
            
            headerWriter.write(element_enum_string);
            
            if (!group.errors.isEmpty())
            {
                headerWriter.write(TYPEDEF_ENUM_STRING);
                
                for (int i=0; i < group.errors.size(); i++)
                {
                    NameStruct error = group.errors.get(i);
                    
                    String enumString = getEnumString(group.name, ERROR_STRING, error.name);
                    if (i == 0)
                    {
                        if (!globalerrors.isEmpty())
                        {
                            enumString += " = " +  GROUP_ERROR_STRING + UNDERSCORE + COUNT_STRING;
                        }
                        else if (!ConfigGenerator.allErrorList.isEmpty() || !ConfigGenerator.groupErrorList.isEmpty())
                        {
                            enumString += " = " +  GLOBAL_ERROR_STRING + UNDERSCORE + COUNT_STRING;
                        }
                        else
                        {
                            enumString += " = 1";
                            
                        }
                    }
                    enumString += ",\n";
                    
                    headerWriter.write(enumString);
                }
                headerWriter.write(endEnumString(group.name, ERROR_STRING));
            }
            
        }

        /* write group enum buffer to headerWriter */
        group_enum_string += endEnumString(null);
        headerWriter.write(group_enum_string);
    }

    public void SourceFileDone() throws IOException
    {
        headerWriter.flush();
        headerWriter.close();
        
        sourceWriter.flush();
        sourceWriter.close();
    }

    private String COMMENTED(String comment)
    {
        return " /*" + comment + "*/\n";
    }
    
    private String getEnumString(String group_name)
    {
        String str = SPACES + IDIGI_STRING + UNDERSCORE + configType;

        if (group_name != null)
        {
            str += UNDERSCORE + group_name;
        }
        return str;
    }
    
    private String getEnumString(String group_name, String name)
    {
        return (getEnumString(group_name) + UNDERSCORE + name);
    }
    
    private String getEnumString(String group_name, String name, String name1)
    {
        return (getEnumString(group_name, name) + UNDERSCORE + name1);
    }

    final static String INT_MAX_WIDTH_STRING = "_WIDTH = INT_MAX\n}";
    final static String ID_T_STRING = "_id_t;\n\n";

    private String endEnumString(String group_name)
    {
        return (getEnumString(group_name) + INT_MAX_WIDTH_STRING + 
                getEnumString(group_name) + ID_T_STRING);
    }

    private String endEnumString(String group_name, String name)
    {
        return (getEnumString(group_name, name) + INT_MAX_WIDTH_STRING + 
                getEnumString(group_name, name) + ID_T_STRING);
    }
    
    private String getDefineString(String name)
    {
        return (configType.toUpperCase() + UNDERSCORE + name.toUpperCase());
    }
    private String getDefineString(String name, String name1)
    {
        return (getDefineString(name) + UNDERSCORE + name1.toUpperCase());
    }

    private String getDefineString(String name, String name1, String name2)
    {
        return (getDefineString(name, name1) + UNDERSCORE + name2.toUpperCase());
    }

    private String getDefineLength(String name, String vname)
    {
        return (DEFINE_STRING + name + UNDERSCORE + LENGTH_STRING.toUpperCase()  +  SPACES + vname.length() + "\n");
    }
    
    
    private String getDefineIndex(String name, String prev_name)
    {
        String indexValueString;
        
        if (prev_name == null)
        {
            indexValueString = "0";
        }
        else
        {
            indexValueString = prev_name + UNDERSCORE + LENGTH_STRING.toUpperCase() +  
                               ADD +(prev_name + UNDERSCORE + INDEX_STRING.toUpperCase()) + " +1\n";
        }
        
        return (DEFINE_STRING + name + UNDERSCORE + INDEX_STRING.toUpperCase()  +  SPACES + indexValueString + "\n");
    }
    
    private String getCharString(String define_name, String name)
    {
        char[] characters = name.toCharArray();
        
        String quote_char = SPACES + define_name + UNDERSCORE + LENGTH_STRING + ",";
        
        for (int i=0; i < characters.length; i++)
        {
            quote_char += "\'" + characters[i] +"\',";
        }
        quote_char += "\n";
        
        return quote_char;
    }
    
    private String getRemoteAllString(String define_name)
    {
        return ( SPACES + "&" + IDIGI_REMOTE_ALL_STRING + "[" + define_name + UNDERSCORE + INDEX_STRING.toUpperCase() + "]");

    }

    private String getRemoteAllString(String define_name, String name)
    {
        return ( SPACES + "&" + IDIGI_REMOTE_ALL_STRING + "[" + define_name + UNDERSCORE + name.toUpperCase() + UNDERSCORE + INDEX_STRING.toUpperCase() + "]");

    }
    private String getElementDefine(String type_name, String name)
    {
        return (SPACES + IDIGI_STRING + UNDERSCORE + "element" + UNDERSCORE + type_name + UNDERSCORE + name + ",\n");
    }
    
    private BufferedWriter sourceWriter;
    private BufferedWriter headerWriter;
    private String configType;
    private String previousName;

    
}
