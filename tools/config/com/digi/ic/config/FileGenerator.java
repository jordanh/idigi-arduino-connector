package com.digi.ic.config;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Date;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.LinkedList;

public class FileGenerator {

    private final static String HEADER_FILENAME = "remote_config.h";
    private final static String SOURCE_FILENAME = "remote_config.c"; 
    
    final static String SPACES = "    ";
    final static String UNDERSCORE = "_";
    final static String ADD = " + ";
    
    final static String IDIGI = "idigi";
    final static String DEFINE = "#define ";
    final static String ERROR = "error";
    
    final static String INCLUDE_HEADER = "#include \"idigi_remote.h\"\n\n";
    
    final static String TYPEDEF_ENUM = "typedef enum {\n";
    
    private final static String GLOBAL_RCI_ERROR = "idigi_rci_error";
    private final static String GLOBAL_ERROR = "idigi_global_error";

    final static String IDIGI_REMOTE_ALL_STRING = "idigi_remote_all_strings";
    
    final static String IDIGI_ERROUR_ENUM_COUNT = "idigi_group_error_COUNT,\n";
    final static String COUNT_STRING = "COUNT";
    
    final static String CHAR_CONST_STRING = "static char const * const ";
    final static String ENUM_STRING = "enum";

    final static String RCI_PARSER_USES_ERROR_DESCRIPTIONS = "RCI_PARSER_USES_ERROR_DESCRIPTIONS\n";
    final static String RCI_PARSER_USES_ENUMERATIONS = "RCI_PARSER_USES_ENUMERATIONS\n";
    final static String RCI_PARSER_USES_FLOATING_POINT = "RCI_PARSER_USES_FLOATING_POINT\n";
    
    public FileGenerator() throws IOException 
    {
        
        headerWriter = new BufferedWriter(new FileWriter(HEADER_FILENAME));
        sourceWriter = new BufferedWriter(new FileWriter(SOURCE_FILENAME));
        ConfigGenerator generator = new ConfigGenerator();
        
        DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
        Date date = new Date();
        
        String note_string = "/*\n * This is an auto-generated file - DO NOT EDIT! \n";
        note_string += " * This is generated by " + generator.getClass().getName() + " tool \n";
        note_string += " * This file was generated on: " + dateFormat.format(date) + " \n";
        note_string += " * The command line arguments were: " + ConfigGenerator.getArgumentListString() + " \n";
        note_string += " * The version of " + generator.getClass().getName() + " tool was: " + ConfigGenerator.VERSION + "\n*/\n\n";
        
        headerWriter.write(note_string);
        sourceWriter.write(note_string);
        
    }
    
    public void SourceFileDone() throws IOException
    {
        headerWriter.flush();
        headerWriter.close();
        
        sourceWriter.flush();
        sourceWriter.close();
    }

    public void generateFile(ConfigData configData) throws IOException
    {
        try {

            headerWriter.write("#ifndef REMOTE_CONFIG_H\n" + 
                                "#define REMOTE_CONFIG_H\n\n" + 
                                INCLUDE_HEADER); // H file header
            
            if (!ConfigGenerator.getLimitErrorDescription())
            {
                headerWriter.write(DEFINE + RCI_PARSER_USES_ERROR_DESCRIPTIONS);
            }
            if (Parser.getEnumSupport())
            {
                headerWriter.write(DEFINE + RCI_PARSER_USES_ENUMERATIONS);
            }
            if (Parser.getEnumSupport())
            {
                headerWriter.write(DEFINE + RCI_PARSER_USES_FLOATING_POINT);
            }

            sourceWriter.write(INCLUDE_HEADER); //  C file include
            
            /* Write all global error enum in H file */
            writeGlobalErrorHeader(configData.getErrorGroups());

            /* Write all group enum in H file */
            writeGroupHeader(configData);
            
            headerWriter.write("\n#endif /* REMOTE_CONFIG_H */\n"); // end of H file

            /* Start writing C file */
            
            /* Write all string length and index defines in C file */
            writeDefineGlobalErrors(configData.getErrorGroups());
            
            /* write idigi remote all strings in source file */
            sourceWriter.write("\nchar const " + IDIGI_REMOTE_ALL_STRING + "[] = {\n");
            
            for (ConfigData.ConfigType type: ConfigData.ConfigType.values())
            {
                LinkedList<GroupStruct> theConfig = null;
                
                configType = type.toString().toLowerCase();
                
                try {
                    
                    theConfig = configData.getConfigGroup(configType);
                    
                } catch (IOException e) {
                    /* end of the ConfigData ConfigType */
                    break;
                }
                
                if (!theConfig.isEmpty())
                {
                    writeRemoteAllStrings(theConfig);
                }
            }
            writeErrorsRemoteAllStrings(configData.getErrorGroups());
            sourceWriter.write(SPACES + "\'\\0\'\n};\n"); // end of IDIGI_REMOTE_ALL_STRING

            /* write structures in source file */
            writeStructures(configData);
            
        } catch (IOException e) {
            throw new IOException(e.getMessage());
        }
    }
    private void writeDefineStrings(LinkedList<GroupStruct> groups) throws IOException
    {
        String defineName = null;

        
        for (GroupStruct group: groups)
        {
            defineName = getDefineString(group.name);
            /* define name string index */
            sourceWriter.write(getDefineIndex(defineName, group.name));
            
            for (ElementStruct element: group.elements)
            {
                defineName = getDefineString(group.name, element.name);
                /* define name string index */
                sourceWriter.write(getDefineIndex(defineName, element.name));

                if (ElementStruct.ElementType.toElementType(element.type) == ElementStruct.ElementType.ENUM)
                {
                    for (NameStruct value: element.values)
                    {
                        defineName = getDefineString(group.name, element.name, value.name);
                        /* define name string index */
                        sourceWriter.write(getDefineIndex(defineName, value.name));
                    }
                 }
            }
        
            if (!ConfigGenerator.getLimitErrorDescription() && !group.errors.isEmpty())
            {
                
                for (NameStruct error: group.errors)
                {
                    defineName = getDefineString(group.name, ERROR, error.name);
                    /* define name string index */
                    sourceWriter.write(getDefineIndex(defineName, error.name));
                }
            }
        }
    }

    private void writeRemoteAllStrings(LinkedList<GroupStruct> groups) throws IOException
    {
        String define_name;
        
        
        for (GroupStruct group: groups)
        {
            define_name = getDefineString(group.name);
            
            sourceWriter.write(getCharString(define_name, group.name));

            for (ElementStruct element: group.elements)
            {
                define_name = getDefineString(group.name, element.name);
                sourceWriter.write(getCharString(define_name, element.name));
                
                if (ElementStruct.ElementType.toElementType(element.type) == ElementStruct.ElementType.ENUM)
                {
                    for (NameStruct value: element.values)
                    {
                        define_name = getDefineString(group.name, element.name, value.name);
                        sourceWriter.write(getCharString(define_name, value.name));
                    }
                 }
            }
        
            if (!ConfigGenerator.getLimitErrorDescription() && !group.errors.isEmpty())
            {
                for (NameStruct error: group.errors)
                {
                    define_name = getDefineString(group.name, ERROR, error.name);
                    sourceWriter.write(getCharString(define_name, error.name));
                }
            }
        }
    }

    private void writeDefineGlobalErrors(LinkedList<NameStruct> globalerrors) throws IOException
    {
        if (!ConfigGenerator.getLimitErrorDescription())
        {
            for (NameStruct error: ConfigGenerator.allErrorList)
            {
                String defineName = GLOBAL_RCI_ERROR.toUpperCase() + UNDERSCORE + error.name.toUpperCase();
                /* define name string index */
                sourceWriter.write(getDefineIndex(defineName, error.name));
            }
            for (NameStruct error: ConfigGenerator.globalErrorList)
            {
                String defineName = GLOBAL_RCI_ERROR.toUpperCase() + UNDERSCORE + error.name.toUpperCase();
                /* define name string index */
                sourceWriter.write(getDefineIndex(defineName, error.name));
            }
            for (NameStruct error: ConfigGenerator.commandErrorList)
            {
                String defineName = GLOBAL_RCI_ERROR.toUpperCase() + UNDERSCORE + error.name.toUpperCase();
                /* define name string index */
                sourceWriter.write(getDefineIndex(defineName, error.name));
            }
            for (NameStruct error: ConfigGenerator.groupErrorList)
            {
                String defineName = GLOBAL_RCI_ERROR.toUpperCase() + UNDERSCORE + error.name.toUpperCase();
                /* define name string index */
                sourceWriter.write(getDefineIndex(defineName, error.name));
            }
            for (NameStruct error: globalerrors)
            {
                String defineName = GLOBAL_ERROR.toUpperCase() + UNDERSCORE + error.name.toUpperCase();
                /* define name string index */
                sourceWriter.write(getDefineIndex(defineName, error.name));
            }
        }
    }

    private void writeErrorsRemoteAllStrings(LinkedList<NameStruct> globalerrors) throws IOException
    {
        if (!ConfigGenerator.getLimitErrorDescription())
        {
            for (NameStruct error: ConfigGenerator.allErrorList)
            {
                String define_name = GLOBAL_RCI_ERROR.toUpperCase() + UNDERSCORE + error.name.toUpperCase();
                sourceWriter.write(getCharString(define_name, error.name));
            }
            for (NameStruct error: ConfigGenerator.globalErrorList)
            {
                String define_name = GLOBAL_RCI_ERROR.toUpperCase() + UNDERSCORE + error.name.toUpperCase();
                sourceWriter.write(getCharString(define_name, error.name));
            }
            for (NameStruct error: ConfigGenerator.commandErrorList)
            {
                String define_name = GLOBAL_RCI_ERROR.toUpperCase() + UNDERSCORE + error.name.toUpperCase();
                sourceWriter.write(getCharString(define_name, error.name));
            }
            for (NameStruct error: ConfigGenerator.groupErrorList)
            {
                String define_name = GLOBAL_RCI_ERROR.toUpperCase() + UNDERSCORE + error.name.toUpperCase();
                sourceWriter.write(getCharString(define_name, error.name));
            }
            for (NameStruct error: globalerrors)
            {
                String define_name = GLOBAL_ERROR.toUpperCase() + UNDERSCORE + error.name.toUpperCase();
                sourceWriter.write(getCharString(define_name, error.name));
            }
        }
    }

    private void writeEnumStructure(String enum_name, LinkedList<NameStruct> values) throws IOException
    {
        String enum_string = enum_name.toLowerCase() + UNDERSCORE + ENUM_STRING;
        
        /* write element enum strings array */
        sourceWriter.write((CHAR_CONST_STRING + enum_string + "[] = {\n"));
        
        for (int value_index = 0; value_index < values.size(); value_index++)
        {
            NameStruct value = values.get(value_index);
            
            /* write idigi_remote_all_strings reference */
            sourceWriter.write(getRemoteAllString(enum_name, value.name));
            if (value_index < (values.size() -1))
            {
                sourceWriter.write(",");
            }
            /* write comment */
            sourceWriter.write(COMMENTED(value.name));
        }
        /* end of writing element enum strings array */
        sourceWriter.write("};\n\n");

        /* write element value limit structure for enum type */
        String enum_limit_string = "static idigi_element_value_enum_t const " + enum_name.toLowerCase() + "_limit = {\n";
        enum_limit_string +=  SPACES + "asizeof(" + enum_string + "), \n" +
                              SPACES + enum_string + "\n};\n\n";

        sourceWriter.write(enum_limit_string);
    }
    
    private void writeElementLimitStructures(String element_name, ElementStruct element) throws IOException
    {
        /* write element value limit structure */
        String limit_string = "static idigi_element_value_unsigned_integer_t const " + element_name.toLowerCase() + "_limit = {\n";
        if (element.min == null)
        {
            limit_string += SPACES + "0";
        }
        else
        {
            limit_string += SPACES + element.min;
        }
        limit_string += ",\n";
        
        if (element.max == null)
        {
            if (ElementStruct.ElementType.toElementType(element.type) == ElementStruct.ElementType.FLOAT)
            {
                limit_string += SPACES + "FLOAT_MAX";
            }
            else
            {
                limit_string += SPACES + "INT_MAX";
            }
        }
        else
        {
            limit_string += SPACES + element.max;
        }
        
        sourceWriter.write(limit_string);
        sourceWriter.write("\n};\n\n");
    }
    
    private void writeElementArrays(String group_name, LinkedList<ElementStruct> elements) throws IOException
    {
        /* write group element structure array */
        sourceWriter.write("static idigi_group_element_t const " + 
                           getDefineString(group_name).toLowerCase() + UNDERSCORE + "elements" +
                           "[] = {");
        
        for (int element_index = 0; element_index < elements.size(); element_index++)
        {
            ElementStruct element = elements.get(element_index);
            
            String element_name = getDefineString(group_name, element.name);
            
            String element_string = "\n" + 
                                    SPACES + "{" + getRemoteAllString(element_name) + ", " + COMMENTED(element.name) + "\n" +
                                    SPACES + getElementDefine("access", getAccess(element.access)) + 
                                    SPACES + getElementDefine("type", element.type);
            
            if (ElementStruct.ElementType.toElementType(element.type) == ElementStruct.ElementType.ENUM ||
                element.min != null || element.max != null)
            {
                element_string += SPACES + SPACES + "(idigi_element_value_limit_t *)&" + 
                                  element_name.toLowerCase() + "_limit";
            }
            else
            {
                element_string += SPACES + SPACES + "NULL";
            }
            element_string += "\n" + SPACES + "}";
            
            if (element_index < (elements.size()-1))
            {
                element_string += ",";
            }
            
            sourceWriter.write(element_string);
        }
        sourceWriter.write("\n};\n\n");

    }

    private void writeErrorStructures(String error_name, LinkedList<NameStruct> localErrors, LinkedList<NameStruct> globalErrors) throws IOException
    {
        if (!ConfigGenerator.getLimitErrorDescription())
        {
            String define_name;
            
            if (!ConfigGenerator.allErrorList.isEmpty() || !ConfigGenerator.groupErrorList.isEmpty() || !localErrors.isEmpty() || !globalErrors.isEmpty())
            {
                define_name = getDefineString(error_name, ERROR);
                sourceWriter.write((CHAR_CONST_STRING + define_name.toLowerCase() + "s[] = {\n"));
    
                /* top-level global errors */
                for (int error_index = 0; error_index < ConfigGenerator.allErrorList.size(); error_index++)
                {
                    NameStruct error = ConfigGenerator.allErrorList.get(error_index);
                    sourceWriter.write(getRemoteAllString(GLOBAL_RCI_ERROR.toUpperCase(), error.name));
                    if (error_index < (ConfigGenerator.allErrorList.size() -1) || 
                       !ConfigGenerator.groupErrorList.isEmpty() ||
                       !localErrors.isEmpty() || !globalErrors.isEmpty())
                    {
                        sourceWriter.write(",");
                    }
                    sourceWriter.write(COMMENTED(error.name));
                }
    
                for (int error_index = 0; error_index < ConfigGenerator.groupErrorList.size(); error_index++)
                {
                    NameStruct error = ConfigGenerator.groupErrorList.get(error_index);
                    sourceWriter.write(getRemoteAllString(GLOBAL_RCI_ERROR.toUpperCase(), error.name));
                    if (error_index < (ConfigGenerator.groupErrorList.size() -1) || 
                        !localErrors.isEmpty() || !globalErrors.isEmpty())
                    {
                        sourceWriter.write(",");
                    }
                    sourceWriter.write(COMMENTED(error.name));
                }
    
                /* group global errors */
                for (int error_index = 0; error_index < globalErrors.size(); error_index++)
                {
                    NameStruct error = globalErrors.get(error_index);
                    
                    sourceWriter.write(getRemoteAllString(GLOBAL_ERROR.toUpperCase(), error.name));
                    if (error_index < (globalErrors.size() -1) ||
                        !localErrors.isEmpty())
                    {
                        sourceWriter.write(",");
                    }
                    sourceWriter.write(COMMENTED(error.name));
                }
                
                /* local local errors */
                define_name = getDefineString(error_name, ERROR);
                for (int error_index = 0; error_index < localErrors.size(); error_index++)
                {
                    NameStruct error = localErrors.get(error_index);
                    
                    sourceWriter.write(getRemoteAllString(define_name, error.name));
                    if (error_index < (localErrors.size() -1))
                    {
                        sourceWriter.write(",");
                    }
                    sourceWriter.write(COMMENTED(error.name));
                }
                
                sourceWriter.write("};\n\n");
            }
        }
    }
    
    private void writeGroupStructures(LinkedList<GroupStruct> groups, LinkedList<NameStruct> globalerrors) throws IOException
    {
        String define_name;
        
        for (int group_index = 0; group_index < groups.size(); group_index++)
        {
            GroupStruct group = groups.get(group_index);
            
            for (int element_index = 0; element_index < group.elements.size(); element_index++)
            {
                ElementStruct element = group.elements.get(element_index);
                
                define_name = getDefineString(group.name, element.name);

                if (ElementStruct.ElementType.toElementType(element.type) == ElementStruct.ElementType.ENUM)
                {
                    /* write enum structure */
                    writeEnumStructure(define_name, element.values);
                }
                else if (element.max != null || element.min != null)
                {
                    /* write limit structure */
                    writeElementLimitStructures(define_name, element);
                }
            }
            
            /* write element structure */
            writeElementArrays(group.name, group.elements);
            
            /* write group error strings array */
            writeErrorStructures(group.name, group.errors, globalerrors);
        }
        
    }

    private void writeStructures(ConfigData configData) throws IOException
    {
        String define_name;
        
        for (ConfigData.ConfigType type: ConfigData.ConfigType.values())
        {
            LinkedList<GroupStruct> groups = null;
            
            configType = type.toString().toLowerCase();
            
            try {
                
                groups = configData.getConfigGroup(configType);
                
            } catch (IOException e) {
                /* end of the ConfigData ConfigType */
                break;
            }

            if (!groups.isEmpty())
            {
                writeGroupStructures(groups, configData.getErrorGroups());
                
                sourceWriter.write("idigi_group_t const idigi_" + configType + "_groups[] = {");
                
                for (int group_index = 0; group_index < groups.size(); group_index++)
                {
                    GroupStruct group = groups.get(group_index);
        
                    
                    define_name = getDefineString(group.name, "elements");
                    String group_string = "\n" + 
                                            SPACES + "{" + getRemoteAllString(getDefineString(group.name)) + ", " + COMMENTED(group.name) + "\n" +
                                            SPACES + SPACES + "1,\n" + 
                                            SPACES + SPACES + (group.instances + 1) + ",\n" +  
                                            SPACES + SPACES + "{" + SPACES + "asizeof(" + define_name.toLowerCase()  + "),\n" +
                                            SPACES + SPACES + SPACES + "&" + define_name.toLowerCase() + "[0]\n" +
                                            SPACES + SPACES + "},\n";
                    
                    if (!ConfigGenerator.getLimitErrorDescription())
                    {
                        define_name = getDefineString(group.name, "errors");
            
                        group_string +=   SPACES + SPACES + "{" + SPACES + "asizeof(" + define_name.toLowerCase() + "),\n" +
                                          SPACES + SPACES + SPACES + "&" + define_name.toLowerCase() + "[0]\n" +
                                          SPACES + SPACES + "}\n" +
                                          SPACES + "}";
                    }
                    else
                    {
                        group_string += SPACES + SPACES + "{" + SPACES + "0,\n" +
                                        SPACES + SPACES + SPACES + "NULL\n}\n" + SPACES + "}";
                    }
                    
                    if (group_index < (groups.size() -1))
                    {
                        group_string += ",";
                    }
                                            
                    sourceWriter.write(group_string);
                }
                sourceWriter.write("\n};\n\n");
            }            
        }
        
        String idigiGroupString = "idigi_group_t const * const idigi_remote_groups[] = {\n";
        String idigiGroupCountString = "";
        
        for (ConfigData.ConfigType type: ConfigData.ConfigType.values())
        {
            LinkedList<GroupStruct> groups = null;
            
            configType = type.toString().toLowerCase();
            
            try {
                
                groups = configData.getConfigGroup(configType);
                
            } catch (IOException e) {
                /* end of the ConfigData ConfigType */
                break;
            }
            
            if (type.getIndex() != 0)
            {
                idigiGroupString += ",\n";
            }
            
            idigiGroupString += SPACES;
            if (!groups.isEmpty())
            {
                idigiGroupString += "idigi_" + configType + "_groups";
                idigiGroupCountString += "size_t const idigi_" + type + "_group_count = asizeof(idigi_" + type + "_groups);\n";

            }
            else
            {
                idigiGroupString += "NULL"; 
                idigiGroupCountString += "size_t const idigi_" + type + "_group_count = 0;\n";

            }
            
        }
        idigiGroupString += "\n};\n\n";
        
        sourceWriter.write(idigiGroupString);
        sourceWriter.write(idigiGroupCountString);
        
    }

    private void writeGlobalErrorHeader(LinkedList<NameStruct> globalerrors) throws IOException
    {
        if (!ConfigGenerator.allErrorList.isEmpty() || !ConfigGenerator.groupErrorList.isEmpty() || !globalerrors.isEmpty())
        {
            /* write typedef enum for error */
            headerWriter.write("\n" + TYPEDEF_ENUM);
            
            for (int i = 0; i < ConfigGenerator.allErrorList.size(); i++)
            {
                NameStruct error = ConfigGenerator.allErrorList.get(i);
                String error_string = SPACES + GLOBAL_RCI_ERROR + UNDERSCORE + error.name;
                
                if (i == 0)
                {
                    error_string += " = 1";
                }
                error_string += ",\n";
                
                headerWriter.write(error_string);
            }
            
            for (int i = 0; i < ConfigGenerator.groupErrorList.size(); i++)
            {
                NameStruct error = ConfigGenerator.groupErrorList.get(i);
                String error_string = SPACES + GLOBAL_RCI_ERROR + UNDERSCORE + error.name;
                
                if (i == 0 && ConfigGenerator.allErrorList.size() == 0)
                {
                    error_string += " = 1";
                }
                error_string += ",\n";
                
                headerWriter.write(error_string);
            }
        
            for (int i = 0; i < globalerrors.size(); i++)
            {
                NameStruct error = globalerrors.get(i);
                String error_string = SPACES + GLOBAL_ERROR + UNDERSCORE + error.name;
                
                if (i == 0 && ConfigGenerator.allErrorList.size() == 0 && ConfigGenerator.groupErrorList.size() == 0)
                {
                    error_string += " = 1";
                }
                    
                error_string += ",\n";
                
                headerWriter.write(error_string);
            }

            headerWriter.write(SPACES + GLOBAL_ERROR + UNDERSCORE + COUNT_STRING + ",\n");
            headerWriter.write(SPACES + GLOBAL_ERROR + INT_MAX_WIDTH_STRING + GLOBAL_ERROR + ID_T_STRING);
            
        }
    }
    private void writeEnumHeader(LinkedList<GroupStruct> groups, LinkedList<NameStruct> globalerrors) throws IOException
    {

        for (GroupStruct group: groups)
        {
            /* build element enum string for element enum */
            String element_enum_string = TYPEDEF_ENUM;
            
            for (ElementStruct element: group.elements)
            {
                /* add element name */
                element_enum_string += getEnumString(group.name, element.name) + ",\n";
                
                if (ElementStruct.ElementType.toElementType(element.type) == ElementStruct.ElementType.ENUM)
                {
                    /* write typedef enum for value */
                    headerWriter.write(TYPEDEF_ENUM);
                    
                    for (NameStruct value: element.values)
                    {
                        headerWriter.write(getEnumString(group.name, element.name, value.name) + ",\n");
                    }
                    /* done typedef enum for value */ 
                    headerWriter.write(endEnumString(group.name, element.name)); 
                }
            }
            /* done typedef enum for element */
            
            element_enum_string += endEnumString(group.name);
            
            headerWriter.write(element_enum_string);
            
            if (!group.errors.isEmpty())
            {
                headerWriter.write(TYPEDEF_ENUM);
                
                for (int i=0; i < group.errors.size(); i++)
                {
                    NameStruct error = group.errors.get(i);
                    
                    String enumString = getEnumString(group.name, ERROR, error.name);
                    if (i == 0)
                    {
                        if (!globalerrors.isEmpty())
                        {
                            enumString += " = " +  GLOBAL_ERROR + UNDERSCORE + COUNT_STRING;
                        }
                        else if (!ConfigGenerator.allErrorList.isEmpty() || !ConfigGenerator.groupErrorList.isEmpty())
                        {
                            enumString += " = " +  GLOBAL_RCI_ERROR + UNDERSCORE + COUNT_STRING;
                        }
                        else
                        {
                            enumString += " = 1";
                            
                        }
                    }
                    enumString += ",\n";
                    
                    headerWriter.write(enumString);
                }
                headerWriter.write(endEnumString(group.name, ERROR));
            }
            
        }

    }

    private void writeGroupHeader(ConfigData configData) throws IOException
    {

        for (ConfigData.ConfigType type: ConfigData.ConfigType.values())
        {
            LinkedList<GroupStruct> groups = null;
            
            configType = type.toString().toLowerCase();
            
            try {
                
                groups = configData.getConfigGroup(configType);
                
            } catch (IOException e) {
                /* end of the ConfigData ConfigType */
                break;
            }
            
            /* build group enum string for group enum */
            String group_enum_string = TYPEDEF_ENUM;
            
            if (!groups.isEmpty())
            {
                /* Write all enum in H file */
                writeEnumHeader(groups, configData.getErrorGroups());
            
                /* Write all string length and index defines in C file */
                writeDefineStrings(groups);
            }

            for (GroupStruct group: groups)
            {
                /* add each group enum */ 
                group_enum_string += getEnumString(group.name) + ",\n";
            }

            /* write group enum buffer to headerWriter */
            group_enum_string += endEnumString(null);
            headerWriter.write(group_enum_string);
        }
        
    }

    private String COMMENTED(String comment)
    {
        return " /*" + comment + "*/\n";
    }
    
    private String getEnumString(String group_name)
    {
        String str = SPACES + IDIGI + UNDERSCORE + configType;

        if (group_name != null)
        {
            str += UNDERSCORE + group_name;
        }
        return str;
    }
    
    private String getEnumString(String group_name, String name)
    {
        return (getEnumString(group_name) + UNDERSCORE + name);
    }
    
    private String getEnumString(String group_name, String name, String name1)
    {
        return (getEnumString(group_name, name) + UNDERSCORE + name1);
    }

    final static String INT_MAX_WIDTH_STRING = "_WIDTH = INT_MAX\n}";
    final static String ID_T_STRING = "_id_t;\n\n";

    private String endEnumString(String group_name)
    {
        return (getEnumString(group_name) + INT_MAX_WIDTH_STRING + 
                getEnumString(group_name) + ID_T_STRING);
    }

    private String endEnumString(String group_name, String name)
    {
        return (getEnumString(group_name, name) + INT_MAX_WIDTH_STRING + 
                getEnumString(group_name, name) + ID_T_STRING);
    }
    
    private String getDefineString(String name)
    {
        return (configType.toUpperCase() + UNDERSCORE + name.toUpperCase());
    }
    private String getDefineString(String name, String name1)
    {
        return (getDefineString(name) + UNDERSCORE + name1.toUpperCase());
    }

    private String getDefineString(String name, String name1, String name2)
    {
        return (getDefineString(name, name1) + UNDERSCORE + name2.toUpperCase());
    }

    private String getDefineIndex(String define_name, String name)
    {
        String str = DEFINE + define_name + SPACES + "(" + IDIGI_REMOTE_ALL_STRING + ADD + prevRemoteStringLength + ")\n";
        prevRemoteStringLength += name.length() + 1;
        return str;
    }

    private String getCharString(String define_name, String name)
    {
        char[] characters = name.toCharArray();
        
        String quote_char = SPACES + name.length() + ",";
        
        for (int i=0; i < characters.length; i++)
        {
            quote_char += "\'" + characters[i] +"\',";
        }
        quote_char += "\n";
        
        return quote_char;
    }
    
    private String getRemoteAllString(String define_name)
    {
      return (SPACES + define_name.toUpperCase());

    }

    private String getRemoteAllString(String define_name, String name)
    {
        return (SPACES + define_name.toUpperCase() + UNDERSCORE + name.toUpperCase());

    }
    private String getElementDefine(String type_name, String name)
    {
        return (SPACES + IDIGI + UNDERSCORE + "element" + UNDERSCORE + type_name + UNDERSCORE + name + ",\n");
    }
    private String getAccess(String access)
    {
        if (access == null)
        {
            return "read_write";
        }
        return access;
    }
    private BufferedWriter sourceWriter;
    private BufferedWriter headerWriter;
    private String configType;
    private int prevRemoteStringLength;

    
}
