package com.digi.ic.config;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Date;
import java.util.LinkedHashMap;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.LinkedList;

public class FileGenerator {

    private final static String HEADER_FILENAME = "remote_config.h";

    private final static String RCI_PREFIX = "RCI_";

    private final static String IDIGI = "idigi";
    private final static String DEFINE = "#define ";
    private final static String INCLUDE = "#include ";
    private final static String ERROR = "error";

    private final static String IDIGI_REMOTE_HEADER = "\"idigi_remote.h\"\n\n";
    private final static String FLOAT_HEADER = "\"float.h\"\n";

    private final static String TYPEDEF_ENUM = "typedef enum {\n";

    private final static String GLOBAL_RCI_ERROR = "idigi_rci_error";
    private final static String GLOBAL_ERROR = "idigi_global_error";

    private final static String IDIGI_REMOTE_ALL_STRING = "idigi_remote_all_strings";
    private final static String IDIGI_REMOTE_GROUP_TABLE = "idigi_group_table";

    private final static String IDIGI_ELEMENT_VALUE_UNSIGNED = "idigi_element_value_unsigned_integer_t";
    private final static String IDIGI_ELEMENT_VALUE_SIGNED = "idigi_element_value_signed_integer_t";
    private final static String IDIGI_ELEMENT_VALUE_STRING = "idigi_element_value_string_t";
    private final static String IDIGI_ELEMENT_VALUE_ENUM = "idigi_element_value_enum_t";
    private final static String IDIGI_ELEMENT_VALUE_FLOAT = "idigi_element_value_float_t";

    private final static String COUNT_STRING = "COUNT";
    private final static String OFFSET_STRING = "OFFSET";
    private final static String STATIC = "static ";
    private final static String CONST = " const ";
    private final static String LIMIT = "limit";

    private final static String CHAR_CONST_STRING = STATIC + "char" + CONST
            + "*" + CONST;
    private final static String ENUM_STRING = "enum";

    private final static String ID_T_STRING = "_id_t;\n\n";
    private final static String TYPEDEF_STRUCT = "\ntypedef struct {\n";

    /* Do not change these (if you do, you also need to update idigi_remote.h */
    private final static String RCI_PARSER_USES = "RCI_PARSER_USES_";
    
    private final static String RCI_PARSER_USES_ERROR_DESCRIPTIONS = RCI_PARSER_USES + "ERROR_DESCRIPTIONS\n";
    private final static String RCI_PARSER_USES_STRINGS = RCI_PARSER_USES + "STRINGS\n";
    private final static String RCI_PARSER_USES_UNSIGNED_INTEGER = RCI_PARSER_USES + "UNSIGNED_INTEGER\n";
    
    private final static String RCI_PARSER_DATA = "IDIGI_RCI_PARSER_INTERNAL_DATA";

    private String headerFile = HEADER_FILENAME;
    private final BufferedWriter headerWriter;
    private String configType;
    private int prevRemoteStringLength;
    private Boolean isFirstRemoteString;

    public FileGenerator(String directoryPath) throws IOException {
        if (directoryPath != null) {
            if (!directoryPath.endsWith("/")) directoryPath += "/";

            headerFile = directoryPath + HEADER_FILENAME;
        }

        headerWriter = new BufferedWriter(new FileWriter(headerFile));

        DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
        Date date = new Date();

        String className = ConfigGenerator.class.getName();

        int firstChar = className.lastIndexOf(".") + 1;
        if (firstChar > 0) {
            className = className.substring(firstChar);
        }

        String note_string = "/*\n * This is an auto-generated file - DO NOT EDIT! \n"
                            + String.format(" * This is generated by %s tool \n", className)
                            + String.format(" * This file was generated on: %s \n", dateFormat.format(date))
                            + String.format(" * The command line arguments were: %s\n", ConfigGenerator.getArgumentLogString())
                            + String.format(" * The version of %s tool was: %s */\n\n", className, ConfigGenerator.VERSION);

        headerWriter.write(note_string);
        
        isFirstRemoteString = true;
    }

    public void generateFile(ConfigData configData) throws Exception {
        try {

            String defineName = HEADER_FILENAME.replace('.', '_').toLowerCase();
            headerWriter.write(String.format("#ifndef %s\n#define %s\n\n", defineName, defineName));
            
            writeHeaderFile(configData);

            /*
             * Start writing:
             * 1. all #define for all strings from user's groups 
             * 2. all #define for all RCI and user's global errors 
             * 3. all strings in idigi_remote_all_strings[]
             */
            headerWriter.write(String.format("\n\n#if defined %s\n\n", RCI_PARSER_DATA));

            /* Write all string length and index defines in C file */
            writeDefineStrings(configData);

            /* Write all string length and index defines in C file */
            writeDefineGlobalErrors(configData);

            /* write idigi remote all strings in source file */
            writeRemoteAllStrings(configData);

            /* write structures in source file */
            writeAllStructures(configData);
            
            headerWriter.write(String.format("\n#endif /* %s */\n\n", RCI_PARSER_DATA));
            
            headerWriter.write(String.format("\n#endif /* %s */\n", defineName));

            ConfigGenerator.log("Files created:\n\t" + headerFile);

        } catch (IOException e) {
            throw new IOException(e.getMessage());
        }

        finally {
            headerWriter.close();
            headerWriter.close();
        }

    }

    private void writeHeaderFile(ConfigData configData) throws Exception {
//        String defineName = HEADER_FILENAME.replace('.', '_').toLowerCase();
//        headerWriter.write(String.format("#ifndef %s\n#define %s\n\n",
//                defineName, defineName));

        writeDefinesAndStructures(configData);
        writeDefineRciParserStringsHeader(configData);

        /* Write all global error enum in H file */
        writeGlobalErrorHeader(configData);

        /* Write all group enum in H file */
        writeGroupHeader(configData);

//        headerWriter.write(String.format("\n#endif /* %s */\n", defineName));
    }

    private void writeOnOffBooleanEnum() throws IOException {

        String enumString = "";
        
        for (ElementStruct.ElementType type : ElementStruct.ElementType.values()) {
            if (type.isSet()) {
                switch (type) {
                case ON_OFF:
                    enumString += "\ntypedef enum {\n"
                                    + "    idigi_off,\n"
                                    + "    idigi_on\n"
                                    + "} idigi_on_off_t;\n";
                    break;
                    
                case BOOLEAN:
                    enumString += "\ntypedef enum {\n"
                                    + "    idigi_boolean_false,\n"
                                    + "    idigi_boolean_true\n"
                                    + "} idigi_boolean_t;\n";
                    break;
                    
                default:
                  break;
                }
            }
        }

        headerWriter.write(enumString);
    }

    private void writeElementTypeEnum() throws IOException {

        String enumString = "\n\ntypedef enum {\n";
        Boolean isFirstEnum = true;
       
        for (ElementStruct.ElementType type : ElementStruct.ElementType.values()) {
            if (type.isSet()) {
                if (!isFirstEnum) {
                    enumString += ",\n";
                }
                isFirstEnum = false;
                
                enumString += "    idigi_element_type_" + type.toName().toLowerCase();
            }
        }

        enumString += "\n} idigi_element_value_type_t;\n";
        headerWriter.write(enumString);
    }

    private void writeElementLimitStruct() throws IOException {

        String headerString = "";
        String structString = "";
        int optionCount = 0;
        
        Boolean isStringDefined = false;
        Boolean isUnsignedIntegerDefined = false;
        
       
        for (ElementStruct.ElementType type : ElementStruct.ElementType.values()) {
            if (type.isSet()) {
                switch (type) {
                case UINT32:
                case HEX32:
                case XHEX:
                    if (!isUnsignedIntegerDefined) {
                        /* if not defined yet, then define it */
                        structString += "    idigi_element_value_unsigned_integer_t unsigned_integer_value;\n";
                        isUnsignedIntegerDefined = true;
                        optionCount++;
                    }
                    break;
                    
                case INT32:
                    structString += "    idigi_element_value_signed_integer_t signed_integer_value;\n";
                    optionCount++;
                    break;
                    
                case ENUM:
                    structString += "    idigi_element_value_enum_t enum_value;\n";
                    optionCount++;
                    break;
                    
                case FLOAT:
                    structString += "    idigi_element_value_float_t float_value;\n";
                    optionCount++;
                    break;
                    
                case ON_OFF:
                   break;
                    
                case BOOLEAN:
                    break;
                    
                default:
                    if (!isStringDefined) {
                        structString += "    idigi_element_value_string_t string_value;\n";
                        isStringDefined = true;
                        optionCount++;
                    }
                  break;
                }
            }
        }

        if (optionCount > 0) {
            
            if (optionCount > 1) 
                headerString += "\n\n typedef union {";
            else 
                headerString += "\n\n typedef struct {";
            
            headerString += "\n" + structString + "} idigi_element_value_limit_t;\n";
        } else {
            headerString += "\n\n typedef void idigi_element_value_limit_t;\n";
        }

        headerWriter.write(headerString);
    }

    private void writeElementValueStruct() throws IOException {

        String headerString = "";
        String structString = "";
        String elementValueStruct = "";
        
        int optionCount = 0;

        Boolean isUnsignedIntegerDefined = false;
        Boolean isStringDefined = false;
        Boolean isEnumValueStructDefined = false;

        for (ElementStruct.ElementType type : ElementStruct.ElementType.values()) {
            if (type.isSet()) {
                switch (type) {
                case UINT32:
                case HEX32:
                case XHEX:
                    if (!isUnsignedIntegerDefined) {
                        /* if not defined yet, then define it */
                        structString += TYPEDEF_STRUCT
                            + "   uint32_t min_value;\n"
                            + "   uint32_t max_value;\n"
                            + "} idigi_element_value_unsigned_integer_t;\n";
                        elementValueStruct += "    uint32_t unsigned_integer_value;\n";
                        isUnsignedIntegerDefined = true;
                        optionCount++;
                    }
                    break;
                    
                case INT32:
                    structString += TYPEDEF_STRUCT
                                    + "   int32_t min_value;\n"
                                    + "   int32_t max_value;\n"
                                    + "} idigi_element_value_signed_integer_t;\n";
                    elementValueStruct += "    int32_t signed_integer_value;\n";
                    optionCount++;
                    break;
                    
                case ENUM:
                    if (!isEnumValueStructDefined) {
                        structString += TYPEDEF_STRUCT
                                        + "    size_t count;\n"
                                        + "    char const * const * value;\n"
                                        + "} idigi_element_value_enum_t;\n";
                        isEnumValueStructDefined = true;
                    }
                    elementValueStruct += "    unsigned int enum_value;\n";
                    optionCount++;
                    break;
                    
                case FLOAT:
                    structString += TYPEDEF_STRUCT
                                    + "    double min_value;\n"
                                    + "    double max_value;\n"
                                    + "} idigi_element_value_float_t;\n";
                    elementValueStruct += "    double float_value;\n";
                    optionCount++;
                    break;
                    
                case ON_OFF:
                    if (!isEnumValueStructDefined) {
                        /* rci parser needs this structure for on/off type */
                        structString += TYPEDEF_STRUCT
                                        + "    size_t count;\n"
                                        + "    char const * const * value;\n"
                                        + "} idigi_element_value_enum_t;\n";
                        isEnumValueStructDefined = true;
                    }
                    elementValueStruct += "    idigi_on_off_t  on_off_value;\n";
                    optionCount++;
                    break;
                    
                case BOOLEAN:
                    if (!isEnumValueStructDefined) {
                        /* rci parser needs this structure for boolean type */
                        structString += TYPEDEF_STRUCT
                                        + "    size_t count;\n"
                                        + "    char const * const * value;\n"
                                        + "} idigi_element_value_enum_t;\n";
                        isEnumValueStructDefined = true;
                    }
                    elementValueStruct += "    idigi_boolean_t  boolean_value;\n";
                    optionCount++;
                    break;
                    
                default:
                    if (!isStringDefined) {
                        /* if not defined yet then define it */
                        structString += TYPEDEF_STRUCT 
                                        + "    size_t min_length_in_bytes;\n"
                                        + "    size_t max_length_in_bytes;\n"
                                        + "} idigi_element_value_string_t;\n";
                        elementValueStruct += "    char const * string_value;\n";
                        isStringDefined = true;
                        optionCount++;
                     }
                    break;
                }
            }
        }
        
        headerString += structString;
        
        if (optionCount > 1) {
            headerString += "\n\ntypedef union {\n";
        } else {
            headerString += "\n\ntypedef struct {\n";
        }
        
        headerString += elementValueStruct + "} idigi_element_value_t;\n";
        
        headerWriter.write(headerString);
    }


    private void writeDefineOptionHeader(ConfigData configData) throws IOException {

        String headerString = "";
        
        if (!ConfigGenerator.excludeErrorDescription()) {
            headerString += DEFINE + RCI_PARSER_USES_ERROR_DESCRIPTIONS;
        }

        String unsignedIntegerString = null;
        String stringsString = null;
        
        String floatInclude = null;

        for (ElementStruct.ElementType type : ElementStruct.ElementType.values()) {
            if (type.isSet()) {
                
                headerString += DEFINE + RCI_PARSER_USES + type.toName().toUpperCase() + "\n";
                
                switch (type) {
                case UINT32:
                case HEX32:
                case XHEX:
                    if (unsignedIntegerString == null) {
                        /* if not defined yet, then define it */
                        unsignedIntegerString = DEFINE + RCI_PARSER_USES_UNSIGNED_INTEGER;
                    }
                    break;
                    
                case INT32:
                case ENUM:
                    break;
                case FLOAT:
                    floatInclude = INCLUDE + FLOAT_HEADER;
                    break;
                    
                case ON_OFF:
                    /* must put before writing the defines and strings */
                    configData.getRciStrings().put("ON", "on");
                    configData.getRciStrings().put("OFF", "off");
                    break;
                    
                case BOOLEAN:
                    /* must put before writing the defines and strings */
                    configData.getRciStrings().put("TRUE", "true");
                    configData.getRciStrings().put("FALSE", "false");
                    break;
                    
                default:
                    if (stringsString == null) {
                        /* if not defined yet then define it */
                        stringsString = DEFINE + RCI_PARSER_USES_STRINGS;
                     }
                    break;
                }
            }
        }
        
        if (unsignedIntegerString != null) headerString += unsignedIntegerString;
        if (stringsString != null) headerString += stringsString;
        
        if (floatInclude != null)
            headerString += "\n\n" + floatInclude;

        headerWriter.write(headerString);
    }

    private void writeDefinesAndStructures(ConfigData configData) throws IOException {


        writeDefineOptionHeader(configData);
        writeOnOffBooleanEnum();
        writeElementTypeEnum();
        writeElementValueStruct();
        writeElementLimitStruct();
        
        String headerString = "\n\n" + INCLUDE + IDIGI_REMOTE_HEADER;

        headerWriter.write(headerString);
    }

    private void writeRemoteAllStrings(ConfigData configData) throws Exception {
        headerWriter.write(String.format("\nchar const %s[] = {\n",
                IDIGI_REMOTE_ALL_STRING));

        writeRemoteRciParserStrings(configData);

        for (ConfigData.ConfigType type : ConfigData.ConfigType.values()) {
            LinkedList<GroupStruct> theConfig = null;

            configType = type.toString().toLowerCase();

            theConfig = configData.getConfigGroup(configType);

            if (!theConfig.isEmpty()) {
                writeGroupRemoteAllStrings(theConfig);
            }
        }
        writeErrorsRemoteAllStrings(configData);
        headerWriter.write("\n};\n\n"); // end of IDIGI_REMOTE_ALL_STRING
    }

    private void writeDefineRciParserStringsHeader(ConfigData configData) throws IOException {
        LinkedHashMap<String, String> rciStrings = configData.getRciStrings();

        if (rciStrings.size() > 0) {
            headerWriter.write(String.format("extern char const %s[];\n\n", IDIGI_REMOTE_ALL_STRING));
        }

        for (String key : rciStrings.keySet()) {
            String defineName = RCI_PREFIX + key.toUpperCase();
            /* define name string index */
            headerWriter.write(getDefineStringIndex(defineName, rciStrings.get(key).toUpperCase()));
        }
    }

    private void writeRemoteRciParserStrings(ConfigData configData) throws IOException {
        LinkedHashMap<String, String> rciStrings = configData.getRciStrings();

        for (String key : rciStrings.keySet()) {
            headerWriter.write(getCharString(rciStrings.get(key)));
        }

    }

    private void writeDefineStrings(ConfigData configData) throws Exception {
        String defineName = null;

        for (ConfigData.ConfigType type : ConfigData.ConfigType.values()) {
            LinkedList<GroupStruct> groups = null;

            configType = type.toString().toLowerCase();

            groups = configData.getConfigGroup(configType);

            for (GroupStruct group : groups) {
                defineName = getDefineString(group.getName());
                /* define name string index */
                headerWriter.write(getDefineStringIndex(defineName, group
                        .getName()));

                for (ElementStruct element : group.getElements()) {
                    defineName = getDefineString(group.getName() + "_" + element.getName());
                    /* define name string index */
                    headerWriter.write(getDefineStringIndex(defineName, element.getName()));

                    if (ElementStruct.ElementType.toElementType(element.getType()) == ElementStruct.ElementType.ENUM) {
                        
                        for (ValueStruct value : element.getValues()) {
                            defineName = getDefineString(group.getName() + "_" + element.getName() + "_" + value.getName());
                            /* define name string index */
                            headerWriter.write(getDefineStringIndex(defineName, value.getName()));
                        }
                    }
                }

                if ((!ConfigGenerator.excludeErrorDescription()) && (!group.getErrors().isEmpty())) {
                    LinkedHashMap<String, String> errorMap = group.getErrors();
                    for (String key : errorMap.keySet()) {
                        defineName = getDefineString(group.getName() + "_" + ERROR + "_" + key);
                        /* define name string index */
                        headerWriter.write(getDefineStringIndex(defineName, errorMap.get(key)));
                    }
                }
            }
        }
    }

    private void writeGroupRemoteAllStrings(LinkedList<GroupStruct> groups) throws Exception {
        for (GroupStruct group : groups) {
            headerWriter.write(getCharString(group.getName()));

            for (ElementStruct element : group.getElements()) {
                headerWriter.write(getCharString(element.getName()));

                if (ElementStruct.ElementType.toElementType(element.getType()) == ElementStruct.ElementType.ENUM) {
                    for (ValueStruct value : element.getValues()) {
                        headerWriter.write(getCharString(value.getName()));
                    }
                }
            }

            if ((!ConfigGenerator.excludeErrorDescription()) && (!group.getErrors().isEmpty())) {
                LinkedHashMap<String, String> errorMap = group.getErrors();
                for (String key : errorMap.keySet()) {
                    headerWriter.write(getCharString(errorMap.get(key)));
                }
            }
        }
    }

    private void writeDefineErrors(String prefixName, LinkedHashMap<String, String> errorMap) throws IOException {
        for (String key : errorMap.keySet()) {
            String defineName = prefixName.toUpperCase() + "_" + key.toUpperCase();
            /* define name string index */
            headerWriter.write(getDefineStringIndex(defineName, errorMap.get(key)));
        }
    }

    private void writeDefineGlobalErrors(ConfigData configData) throws IOException {
        if (!ConfigGenerator.excludeErrorDescription()) {
            writeDefineErrors(GLOBAL_ERROR, configData.getUserGlobalErrors());
            
            writeDefineErrors(GLOBAL_RCI_ERROR, configData.getRciCommonErrors());

            writeDefineErrors(GLOBAL_RCI_ERROR, configData.getRciGlobalErrors());

            writeDefineErrors(GLOBAL_RCI_ERROR, configData.getRciCommandErrors());

            writeDefineErrors(GLOBAL_RCI_ERROR, configData.getRciGroupErrors());

        }
    }

    private void writeLinkedHashMapStrings(LinkedHashMap<String, String> stringMap) throws IOException {
        for (String key : stringMap.keySet()) {
            headerWriter.write(getCharString(stringMap.get(key)));
        }
    }

    private void writeErrorsRemoteAllStrings(ConfigData configData) throws IOException {
        if (!ConfigGenerator.excludeErrorDescription()) {
            writeLinkedHashMapStrings(configData.getUserGlobalErrors());
            
            writeLinkedHashMapStrings(configData.getRciCommonErrors());

            writeLinkedHashMapStrings(configData.getRciGlobalErrors());

            writeLinkedHashMapStrings(configData.getRciCommandErrors());

            writeLinkedHashMapStrings(configData.getRciGroupErrors());

        }
    }

    private void writeEnumStructure(String enum_name, LinkedList<ValueStruct> values) throws IOException {
        String enum_string = enum_name.toLowerCase() + "_" + ENUM_STRING;

        /* write element enum strings array */
        headerWriter.write(CHAR_CONST_STRING + enum_string + "[] = {\n");


        int size = values.size();
        
        for (int i=0; i < size; i++)
        {
            ValueStruct value = values.get(i);
            
            /* write idigi_remote_all_strings reference */
            headerWriter.write(getRemoteString(enum_name + "_" + value.getName()));
            
            if (i < (size-1)) headerWriter.write(",");
            /* write comment */
            headerWriter.write(COMMENTED(value.getName()));
        }
        /* end of writing element enum strings array */
        headerWriter.write("};\n\n");

        /* write element value limit structure for enum type */
        String enum_limit_string = String.format("static %s const %s_limit = {\n asizeof(%s),\n %s\n};\n\n",
                                                IDIGI_ELEMENT_VALUE_ENUM, enum_name.toLowerCase(), enum_string,
                                                enum_string);

        headerWriter.write(enum_limit_string);
    }

    private void writeElementLimitStructures(String element_name, ElementStruct element) throws Exception {
        /* write element value limit structure */
        String limit_string = STATIC;

        ElementStruct.ElementType type = ElementStruct.ElementType.toElementType(element.getType());

        switch (type) {
        case FLOAT:
            limit_string += IDIGI_ELEMENT_VALUE_FLOAT;
            break;
        case UINT32:
        case HEX32:
        case XHEX:
            limit_string += IDIGI_ELEMENT_VALUE_UNSIGNED;
            break;
        case INT32:
            limit_string += IDIGI_ELEMENT_VALUE_SIGNED;
            break;
        default:
            limit_string += IDIGI_ELEMENT_VALUE_STRING;
            break;
        }

        limit_string += CONST + element_name.toLowerCase() + "_" + LIMIT + " = {\n";

        if (element.getMin() == null) {
            switch (type) {
            case FLOAT:
                limit_string += " " + "FLT_MIN";
                break;
            case INT32:
                limit_string += " " + "INT32_MIN";
                break;
            default:
                limit_string += " " + "0";
                break;
            }
        } else {
            limit_string += " ";
            if (type == ElementStruct.ElementType.HEX32)
                limit_string += "0x";
            limit_string += element.getMin();
        }

        limit_string += ",\n";

        if (element.getMax() == null) {
            switch (type) {
            case FLOAT:
                limit_string += " " + "FLT_MAX";
                break;
            case INT32:
                limit_string += " " + "INT32_MAX";
                break;
            case UINT32:
            case HEX32:
            case XHEX:
                limit_string += " " + "UINT32_MAX";
                break;
            default:
                limit_string += " " + "SIZE_MAX";
                break;
            }
        } else {
            limit_string += " ";
            if (type == ElementStruct.ElementType.HEX32) limit_string += "0x";
            limit_string += element.getMax();
        }

        headerWriter.write(limit_string);
        headerWriter.write("\n};\n\n");
    }

    private void writeElementArrays(String group_name, LinkedList<ElementStruct> elements) throws Exception {
        /* write group element structure array */
        headerWriter.write(String.format("static idigi_group_element_t const %s_elements[] = {",
                                        getDefineString(group_name).toLowerCase()));

        for (int element_index = 0; element_index < elements.size(); element_index++) {
            ElementStruct element = elements.get(element_index);

            String element_name = getDefineString(group_name + "_" + element.getName());

            String element_string = "\n"
                                    + " "
                                    + "{"
                                    + getRemoteString(element_name)
                                    + ", "
                                    + COMMENTED(element.getName())
                                    + "  "
                                    + getElementDefine("access", getAccess(element.getAccess()))
                                    + "  " 
                                    + getElementDefine("type", element.getType());

            if ((ElementStruct.ElementType.toElementType(element.getType()) == ElementStruct.ElementType.ENUM)
                  || (element.getMin() != null) || (element.getMax() != null)) {
                
                element_string += String.format("  (idigi_element_value_limit_t *)&%s_limit",
                                                element_name.toLowerCase());
            } else {
                element_string += "  NULL";
            }
            element_string += "\n }";

            if (element_index < (elements.size() - 1)) {
                element_string += ",";
            }

            headerWriter.write(element_string);
        }
        headerWriter.write("\n};\n\n");

    }

    private void writeGlobalErrorStructures(ConfigData configData) throws IOException {
        
        if (!ConfigGenerator.excludeErrorDescription()) {
            int errorCount = configData.getRciCommonErrors().size()
                            + configData.getRciGlobalErrors().size()
                            + configData.getRciCommandErrors().size()
                            + configData.getRciGroupErrors().size()
                            + configData.getUserGlobalErrors().size();

            if (errorCount > 0) {
                headerWriter.write(String.format("static char const * const %ss[] = {\n", GLOBAL_RCI_ERROR));
                        
                /* top-level all errors */
                errorCount = writeErrorStructures(errorCount, GLOBAL_RCI_ERROR,
                             configData.getRciCommonErrors());

                /* top-level global errors */
                errorCount = writeErrorStructures(errorCount, GLOBAL_RCI_ERROR,
                             configData.getRciGlobalErrors());

                /* top-level command errors */
                errorCount = writeErrorStructures(errorCount, GLOBAL_RCI_ERROR,
                             configData.getRciCommandErrors());

                /* top-level group errors */
                errorCount = writeErrorStructures(errorCount, GLOBAL_RCI_ERROR,
                             configData.getRciGroupErrors());

                /* group global errors */
                errorCount = writeErrorStructures(errorCount, GLOBAL_ERROR,
                             configData.getUserGlobalErrors());

                headerWriter.write("};\n\n");
            }
        }
    }

    private int writeErrorStructures(int errorCount, String defineName, LinkedHashMap<String, String> errorMap) throws IOException {
        
        for (String key : errorMap.keySet()) {
            headerWriter.write(getRemoteString(defineName.toUpperCase() + "_" + key));
            errorCount--;
            if (errorCount > 0) {
                headerWriter.write(",");
            }
            headerWriter.write(COMMENTED(key));
        }

        return errorCount;
    }

    private void writeErrorStructures(String error_name, LinkedHashMap<String, String> localErrors) throws IOException {
        
        if (!ConfigGenerator.excludeErrorDescription()) {
            String define_name;

            if (!localErrors.isEmpty()) {
                define_name = getDefineString(error_name + "_" + ERROR);
                headerWriter.write(CHAR_CONST_STRING + define_name.toLowerCase() + "s[] = {\n");

                /* local local errors */
                define_name = getDefineString(error_name + "_" + ERROR);
                int error_count = localErrors.size();
                writeErrorStructures(error_count, define_name, localErrors);

                headerWriter.write("};\n\n");
            }
        }
    }

    private void writeGroupStructures(LinkedList<GroupStruct> groups) throws Exception {
        
        String define_name;

        for (int group_index = 0; group_index < groups.size(); group_index++) {
            GroupStruct group = groups.get(group_index);

            for (int element_index = 0; element_index < group.getElements()
                    .size(); element_index++) {
                ElementStruct element = group.getElements().get(element_index);

                define_name = getDefineString(group.getName() + "_" + element.getName());

                if (ElementStruct.ElementType.toElementType(element.getType()) == ElementStruct.ElementType.ENUM) {
                    /* write enum structure */
                    writeEnumStructure(define_name, element.getValues());
                } else if (element.getMax() != null || element.getMin() != null) {
                    /* write limit structure */
                    writeElementLimitStructures(define_name, element);
                }
            }

            /* write element structure */
            writeElementArrays(group.getName(), group.getElements());

            writeErrorStructures(group.getName(), group.getErrors());
        }

    }

    private void writeAllStructures(ConfigData configData) throws Exception {
        String define_name;

        for (ConfigData.ConfigType type : ConfigData.ConfigType.values()) {
            LinkedList<GroupStruct> groups = null;

            configType = type.toString().toLowerCase();

            groups = configData.getConfigGroup(configType);

            if (!groups.isEmpty()) {
                writeGroupStructures(groups);

                headerWriter.write(String.format("static idigi_group_t const idigi_%s_groups[] = {", configType));

                for (int group_index = 0; group_index < groups.size(); group_index++) {
                    GroupStruct group = groups.get(group_index);

                    define_name = getDefineString(group.getName() + "_elements");
                    String group_string = String.format("\n {%s, %s", 
                                                        getRemoteString(getDefineString(group.getName())),
                                                        COMMENTED(group.getName()))
                                        + String.format("   %d,\n", group.getInstances())
                                        + String.format("   { asizeof(%s),\n", define_name.toLowerCase())
                                        + String.format("     %s\n   },\n", define_name.toLowerCase());

                    if ((!ConfigGenerator.excludeErrorDescription()) && (!group.getErrors().isEmpty())) {
                        define_name = getDefineString(group.getName() + "_errors");

                        group_string += String.format("   { asizeof(%s),\n", define_name.toLowerCase())
                                        + String.format("     %s\n   }\n }\n", define_name.toLowerCase());

                    } else {
                        group_string += "   { 0,\n     NULL\n   }\n }";
                    }

                    if (group_index < (groups.size() - 1)) {
                        group_string += ",";
                    }

                    headerWriter.write(group_string);
                }
                headerWriter.write("\n};\n\n");
            }
        }

        writeGlobalErrorStructures(configData);

        String idigiGroupString = String.format("static idigi_group_table_t const %s[] = {\n",
                                                IDIGI_REMOTE_GROUP_TABLE);

        for (ConfigData.ConfigType type : ConfigData.ConfigType.values()) {
            LinkedList<GroupStruct> groups = null;

            configType = type.toString().toLowerCase();

            groups = configData.getConfigGroup(configType);

            if (type.getIndex() != 0) {
                idigiGroupString += ",\n";
            }

            idigiGroupString += " " + "{";
            if (!groups.isEmpty()) {
                idigiGroupString += String.format("idigi_%s_groups,\n asizeof(idigi_%s_groups)\n }",
                                                   configType, configType);

            } else {
                idigiGroupString += "NULL,\n 0\n }";
            }

        }
        idigiGroupString += "\n};\n\n";

        headerWriter.write(idigiGroupString);
    }

    private void writeErrorHeader(int errorIndex, String enumDefine, LinkedHashMap<String, String> errorMap) throws IOException {
        
        for (String key : errorMap.keySet()) {
            String error_string = " " + enumDefine + "_" + key;

            if (errorIndex == 1) {
                error_string += " = " + " " + enumDefine + "_" + OFFSET_STRING;
            }
            errorIndex++;

            error_string += ",\n";

            headerWriter.write(error_string);
        }
    }

    private void writeGlobalErrorHeader(ConfigData configData) throws IOException {

        /* write typedef enum for rci errors */
        headerWriter.write("\n" + TYPEDEF_ENUM + " " + GLOBAL_RCI_ERROR + "_" + OFFSET_STRING + " = 1,\n");

        writeErrorHeader(configData.getRciCommonErrorsIndex(), GLOBAL_RCI_ERROR, configData.getRciCommonErrors());

        writeErrorHeader(configData.getRciGlobalErrorsIndex(), GLOBAL_RCI_ERROR, configData.getRciGlobalErrors());

        writeErrorHeader(configData.getRciCommandErrorsIndex(), GLOBAL_RCI_ERROR, configData.getRciCommandErrors());

        writeErrorHeader(configData.getRciGroupErrorsIndex(), GLOBAL_RCI_ERROR, configData.getRciGroupErrors());

        headerWriter.write(" " + GLOBAL_RCI_ERROR + "_" + COUNT_STRING + "\n} " + GLOBAL_RCI_ERROR + ID_T_STRING);

        /* write typedef enum for user global error */
        String enumName = GLOBAL_ERROR + "_" + OFFSET_STRING;

        headerWriter.write("\n" + TYPEDEF_ENUM + " " + enumName + " = " + GLOBAL_RCI_ERROR + "_" + COUNT_STRING + ",\n");

        writeErrorHeader(1, GLOBAL_ERROR, configData.getUserGlobalErrors());

        String endString = String.format(" %s_%s", GLOBAL_ERROR, COUNT_STRING);

        if (configData.getUserGlobalErrors().isEmpty()) {
            endString += " = " + enumName;
        }
        endString += "\n} " + GLOBAL_ERROR + ID_T_STRING;

        headerWriter.write(endString);

    }

    private void writeEnumHeader(LinkedList<GroupStruct> groups) throws Exception {

        for (GroupStruct group : groups) {
            /* build element enum string for element enum */
            String element_enum_string = TYPEDEF_ENUM;

            for (ElementStruct element : group.getElements()) {
                /* add element name */
                element_enum_string += getEnumString(group.getName() + "_"
                        + element.getName())
                        + ",\n";

                if (ElementStruct.ElementType.toElementType(element.getType()) == ElementStruct.ElementType.ENUM) {
                    /* write typedef enum for value */
                    headerWriter.write(TYPEDEF_ENUM);

                    for (ValueStruct value : element.getValues()) {
                        headerWriter.write(getEnumString(group.getName() + "_" + element.getName() + "_" + value.getName()) + ",\n");
                    }
                    /* done typedef enum for value */
                    headerWriter.write(endEnumString(group.getName() + "_" + element.getName()));
                }
            }
            /* done typedef enum for element */

            element_enum_string += endEnumString(group.getName());

            headerWriter.write(element_enum_string);

            if (!group.getErrors().isEmpty()) {
                headerWriter.write(TYPEDEF_ENUM);

                LinkedHashMap<String, String> errorMap = group.getErrors();
                int index = 0;

                for (String key : errorMap.keySet()) {
                    String enumString = getEnumString(group.getName() + "_" + ERROR + "_" + key);
                    if (index++ == 0) {
                        /* write start index */
                        enumString += " = " + GLOBAL_ERROR + "_" + COUNT_STRING;
                    }

                    enumString += ",\n";

                    headerWriter.write(enumString);
                }
                headerWriter.write(endEnumString(group.getName() + "_" + ERROR));
            }

        }

    }

    private void writeGroupHeader(ConfigData configData) throws Exception {

        for (ConfigData.ConfigType type : ConfigData.ConfigType.values()) {
            LinkedList<GroupStruct> groups = null;

            configType = type.toString().toLowerCase();
            groups = configData.getConfigGroup(configType);

            if (!groups.isEmpty()) {
                /* build group enum string for group enum */
                String group_enum_string = TYPEDEF_ENUM;

                /* Write all enum in H file */
                writeEnumHeader(groups);

                for (GroupStruct group : groups) {
                    /* add each group enum */
                    group_enum_string += getEnumString(group.getName()) + ",\n";
                }

                /* write group enum buffer to headerWriter */
                group_enum_string += endEnumString(null);
                headerWriter.write(group_enum_string);
            }
        }

    }

    private String COMMENTED(String comment) {
        return " /*" + comment + "*/\n";
    }

    private String getEnumString(String enum_name) {
        String str = " " + IDIGI + "_" + configType;

        if (enum_name != null) {
            str += "_" + enum_name;
        }
        return str;
    }

    private String endEnumString(String group_name) {
        return (getEnumString(group_name) + "_" + COUNT_STRING + "\n}"
                + getEnumString(group_name) + ID_T_STRING);
    }

    private String getDefineString(String define_name) {
        return (configType.toUpperCase() + "_" + define_name.toUpperCase());
    }

    private String getDefineStringIndex(String define_name, String string) {
        String str = DEFINE + define_name + " " + "(" + IDIGI_REMOTE_ALL_STRING + "+" + prevRemoteStringLength + ")\n";
        if (string != null) {
            prevRemoteStringLength += string.length();
        }
        prevRemoteStringLength++;
        
        return str;
    }

    private String getCharString(String string) {
        
        String quote_char = (isFirstRemoteString) ? "": ",\n";
        
        isFirstRemoteString = false;
        
        if (string != null) {
            
            char[] characters = string.toCharArray();
    
            quote_char += " " + string.length() + ",";
    
            int length = characters.length;
            
            for (int i=0; i < length; i++)
            {
                quote_char += "\'" + characters[i] + "\'";
                if (i < length-1) {
                    //last character
                    quote_char += ",";
                }
                
            }
        }
        else {
            quote_char += " 0";
        }
            

        return quote_char;
    }

    private String getRemoteString(String define_name) {
        return (" " + define_name.toUpperCase());

    }

    private String getElementDefine(String type_name, String element_name) {
        return (String.format(" %s_element_%s_%s,\n", IDIGI, type_name, element_name));
    }

    private String getAccess(String access) {
        if (access == null) {
            return "read_write";
        }
        return access;
    }

}
